# LeetCode #924 - Minimize Malware Spread
# https://leetcode.com/problems/minimize-malware-spread/
# By recursive DFS (biggest component with a unique initial node).

# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread(graph, initial)
  candidates = component_sizes(graph, Set.new(initial))
    .filter { |matches, _| matches.size == 1 }
    .map { |matches, count| [matches.first, count] }

  return initial.min if candidates.empty?

  root, _ = candidates.min_by { |root, count| [-count, root] }
  root
end

def component_sizes(graph, roots)
  vis = [false] * graph.size

  dfs = lambda do |src, matches|
    return 0 if vis[src]

    vis[src] = true

    if roots.include?(src)
      roots.delete(src)
      matches << src
    end

    acc = 1

    graph[src].each_with_index do |entry, dest|
      acc += dfs.call(dest, matches) unless entry.zero?
    end

    acc
  end

  ret = []

  until roots.empty?
    matches = []
    ret << [matches, dfs.call(roots.first, matches)]
  end

  ret
end
