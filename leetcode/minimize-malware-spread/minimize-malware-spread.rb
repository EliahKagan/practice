# LeetCode #924 - Minimize Malware Spread
# https://leetcode.com/problems/minimize-malware-spread/
# By union-find (biggest component with a unique initial node).

# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread(graph, initial)
  sets = build_sets(graph)

  candidates = initial
    .group_by { |v| sets.find_set(v) }
    .values
    .filter { |g| g.size == 1 }
    .map(&:first)

  return initial.min if candidates.empty?

  candidates.min_by { |v| [-sets.size(v), v] }
end

def build_sets(graph)
  sets = DisjointSets.new(graph.size)

  0.upto(graph.size - 2) do |i|
    (i + 1).upto(graph.size - 1) do |j|
      sets.union(i, j) unless graph[i][j].zero?
    end
  end

  sets
end

# A disjoint-set union data structure for union-find and component size queries.
class DisjointSets
  def initialize(total_size)
    @parents = (0...total_size).to_a
    @sizes = [1] * total_size
  end

  def find_set(elem)
    raise 'element out of range' unless elem.between?(0, total_size - 1)

    do_find_set(elem)
  end

  def union(elem1, elem2)
    # Find the ancestors and stop if they are already the same.
    elem1 = find_set(elem1)
    elem2 = find_set(elem2)
    return if elem1 == elem2

    # Unite by size.
    if @sizes[elem1] < @sizes[elem2]
      join(elem2, elem1)
    else
      join(elem1, elem2)
    end
  end

  def size(elem)
    @sizes[find_set(elem)]
  end

  private

  def total_size
    @parents.size
  end

  def do_find_set(elem)
    @parents[elem] = do_find_set(@parents[elem]) if elem != @parents[elem]
    @parents[elem]
  end

  def join(parent, child)
    @parents[child] = parent
    @sizes[parent] += @sizes[child]
    nil
  end
end
