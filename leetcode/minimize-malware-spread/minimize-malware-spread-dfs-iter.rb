# LeetCode #924 - Minimize Malware Spread
# https://leetcode.com/problems/minimize-malware-spread/
# By iterative DFS (biggest component with a unique initial node).

# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread(graph, initial)
  candidates = component_sizes(graph, Set.new(initial))
    .filter { |matches, _| matches.size == 1 }
    .map { |matches, count| [matches.first, count] }

  return initial.min if candidates.empty?

  root, _ = candidates.min_by { |root, count| [-count, root] }
  root
end

def component_sizes(graph, roots)
  vis = [false] * graph.size

  dfs = lambda do |start|
    stack = []
    count = 0
    matches = []

    visit = lambda do |vertex|
      return if vis[vertex]

      vis[vertex] = true
      stack << vertex
      count += 1

      return unless roots.include?(vertex)

      roots.delete(vertex)
      matches << vertex
    end

    visit.call(start)

    until stack.empty?
      graph[stack.pop].each_with_index do |entry, dest|
        visit.call(dest) unless entry.zero?
      end
    end

    [matches, count]
  end

  ret = []
  ret << dfs.call(roots.first) until roots.empty?
  ret
end
